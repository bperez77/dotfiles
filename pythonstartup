#-----------------------------------------------------------------------------------------------------------------------
#
# Python Startup File
#
# Author:           Brandon Perez <bmperez@alumni.cmu.edu>
# Creation Date:    Tuesday, February 16, 2016 at 11:19:26 AM EDT
#
# This file is executed whenever an interactive Python session starts up, and it sets up persistent command history, tab
# completion, and default imported modules for the session.
#
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# Readline Settings
#-----------------------------------------------------------------------------------------------------------------------

def _setup_readline():
    """Sets up tab completion and persistent command history for the interactive session."""

    # The readline library is only supported on Linux and Mac system.
    import platform
    if platform.system().lower() != 'linux':
        return

    # General Imports
    import atexit
    from os import path

    # Readline Imports
    import readline
    import rlcompleter

    # Enable tab completion to be used in the Python interpreter.
    readline.parse_and_bind('tab: complete')

    # Set the persistent command history to be unlimited in size.
    readline.set_history_length(-1)

    # Read the contents of the Inputrc initialization file to get the standard readline settings.
    inputrc_path = path.join(path.expanduser('~'), '.inputrc')
    readline.read_init_file(inputrc_path)

    # Read the contents of the Python history file if one currently exists to get the command history.
    history_path = path.join(path.expanduser('~'), '.python_history')
    if path.exists(history_path):
        readline.read_history_file(history_path)

    # When the interpreter exits, write the new history to the history file to enable persistent command history. Note
    # that this also includes the history that was read from the file, so this is effectively an append operation.
    atexit.register(readline.write_history_file, history_path)

# Remove setup Readline function so it doesn't pollute the interactive session's namespace.
_setup_readline()
del _setup_readline

#-----------------------------------------------------------------------------------------------------------------------
# Prompt Settings
#-----------------------------------------------------------------------------------------------------------------------

def _get_ps1_prompt():
    """Constructs the PS1 prompt used for the interactive session. This is the line printed at the beginning of each
    line in the interpreter."""

    # General Imports
    import platform
    from sys import version_info

    # If Python is being run on a Linux system, then colorize the prompt.
    if platform.system().lower() == 'linux':
        # Get ANSI color and modification codes for terminal text. Note that the \001 and \002 delimiters tell readline
        # not to the characters towards the line length. This is necessary to wrap long lines properly.
        import curses
        curses.setupterm()
        get_color = lambda color: curses.tparm(curses.tigetstr('setaf'), color).decode('utf-8')

        color_dict = {
                'normal':   '\001{}\002'.format(curses.tigetstr('sgr0').decode('utf-8')),
                'green':    '\001{}\002'.format(get_color(curses.COLOR_GREEN)),
                'yellow':   '\001{}\002'.format(get_color(curses.COLOR_YELLOW)),
        }
    else:
        color_dict = {'normal': '', 'green': '', 'yellow': ''}

    # Include the python version in the PS1 prompt
    return '{green}[{yellow}Python-{0.major}.{0.minor}.{0.micro}{green}]>>> {normal}'.format(version_info,
            **color_dict)

def _setup_prompt():
    """Modifies the prompt used for the interactive session."""

    # General Imports
    import sys

    # Override the default prompt used in the interactive session, printed at the beginning of each line.
    sys.ps1 = _get_ps1_prompt()

    # Override the default prompt used for line continuations, so that multiline commands can be copied properly.
    sys.ps2 = ' ' * 8

# Remove the setup prompt function so it doesn't pollute the interactive session's namespace.
_setup_prompt()
del _get_ps1_prompt, _setup_prompt

#-----------------------------------------------------------------------------------------------------------------------
# Default Modules and Defined Functions
#-----------------------------------------------------------------------------------------------------------------------

# Provides an improved version of the `dir` function, for listing the members of an object.
from see import see

def see_filter(obj, pattern):
    """Filters the members of the given object using a wildcard pattern or regex.

    This is a shorthand alias for see(obj).filter(pattern). Note that all members of a object begin with a '.'
    character, so this needs to be in the pattern. Regular expressions can be specified if the string begins with a
    forward-slash '/'.
    """

    return see(obj).filter(pattern)

def wildcard_import_file(python_file_path):
    """Emulates a wildcard import of the Python file at the given path, if it exists.

    This follows the behavior of a wildcard import (i.e. `from module import *`). If the module defines `__all__`, then
    only those names are imported. Otherwise, all names are imported which do not start with an underscore.
    """

    # General Imports
    import importlib
    from os import path

    # If there is no local Python startup file, then we do nothing.
    if not path.exists(python_file_path):
        return

    # Otherwise, dynamically import the module with import lib's facilities.
    python_file_name = path.splitext(path.basename(python_file_path))[0]
    module_loader = importlib.machinery.SourceFileLoader(python_file_name, python_file_path)
    module_spec = importlib.util.spec_from_loader(module_loader.name, module_loader)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)

    # Emulate a wildcard import by importing all user-defined or specified variables into the global namespace. This is
    # either the `__all__` attribute, or all names that don't start with an underscore if `__all__` is not defined.
    default_import_variables = [name for name in module.__dict__.keys() if not name.startswith('_')]
    module_user_defined = getattr(module, '__all__', default_import_variables)
    module_variables = {name: getattr(module, name) for name in module_user_defined}
    globals().update(module_variables)

#-----------------------------------------------------------------------------------------------------------------------
# Machine-Local Settings
#-----------------------------------------------------------------------------------------------------------------------

def _import_local_startup():
    """Imports the local Python startup file, if one exists."""

    # General Imports
    from os import path

    local_pythonstartup_path = path.join(path.expanduser('~'), '.pythonstartup_local')
    wildcard_import_file(local_pythonstartup_path)

# Import the local Python startup file if one exists.
_import_local_startup()
del _import_local_startup
