#-----------------------------------------------------------------------------------------------------------------------
#
# Python Startup File
#
# Author:           Brandon Perez <bmperez@alumni.cmu.edu>
# Creation Date:    Tuesday, February 16, 2016 at 11:19:26 AM EDT
#
# This file is executed whenever an interactive Python session starts up, and it sets up persistent command history, tab
# completion, and default imported modules for the session.
#
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# Readline Settings
#-----------------------------------------------------------------------------------------------------------------------

def _setup_readline():
    """Sets up tab completion and persistent command history for the interactive session."""

    # General Imports
    import atexit
    from os import path

    # Readline Imports
    import readline
    import rlcompleter

    # Enable tab completion to be used in the Python interpreter.
    readline.parse_and_bind('tab: complete')

    # Set the persistent command history to be unlimited in size.
    readline.set_history_length(-1)

    # Read the contents of the Python history file if one currently exists to get the command history.
    history_path = path.join(path.expanduser('~'), '.python_history')
    if path.exists(history_path):
        readline.read_history_file(history_path)

    # When the interpreter exits, write the new history to the history file to enable persistent command history. Note
    # that this also includes the history that was read from the file, so this is effectively an append operation.
    atexit.register(readline.write_history_file, history_path)

# Remove setup Readline function so it doesn't pollute the interactive session's namespace.
_setup_readline()
del _setup_readline

#-----------------------------------------------------------------------------------------------------------------------
# Prompt Settings
#-----------------------------------------------------------------------------------------------------------------------

def _get_ps1_prompt():

    # General Imports
    import curses
    import os
    from sys import version_info

    # If Python is being run on a Linux system, then colorize the prompt.
    if os.name.lower() == 'posix':
        # Get ANSI color and modification codes for terminal text. Note that the \001 and \002 delimiters tell readline
        # not to the characters towards the line length. This is necessary to wrap long lines properly.
        curses.setupterm()
        get_color = lambda color: curses.tparm(curses.tigetstr('setaf'), color).decode('utf-8')
        color_dict = {
                'normal':   '\001{}\002'.format(curses.tigetstr('sgr0').decode('utf-8')),
                'green':    '\001{}\002'.format(get_color(curses.COLOR_GREEN)),
                'yellow':   '\001{}\002'.format(get_color(curses.COLOR_YELLOW)),
        }
    else:
        color_dict = {'normal': '', 'green': '', 'yellow': ''}

    # Include the python version in the PS1 prompt
    return '{green}[{yellow}Python-{0.major}.{0.minor}.{0.micro}{green}]>>> {normal}'.format(version_info,
            **color_dict)

def _setup_prompt():
    """Modifies the prompt used for the interactive session."""

    # General Imports
    import sys

    # Override the default prompt used in the interactive session, printed at the beginning of each line.
    sys.ps1 = _get_ps1_prompt()

    # Override the default prompt used for line continuations, so that multiline commands can be copied properly.
    sys.ps2 = ' ' * 4

# Remove the setup prompt function so it doesn't pollute the interactive session's namespace.
_setup_prompt()
del _get_ps1_prompt, _setup_prompt

#-----------------------------------------------------------------------------------------------------------------------
# Default Modules and Defined Functions
#-----------------------------------------------------------------------------------------------------------------------

# Provides an improved version of the `dir` function, for listing the members of an object.
from see import see

def see_filter(obj, pattern):
    """Filters the members of the given object using a wildcard pattern or regex.

    This is a shorthand alias for see(obj).filter(pattern). Note that all members of a object begin with a '.'
    character, so this needs to be in the pattern. Regular expressions can be specified if the string begins with a
    forward-slash '/'.
    """

    return see(obj).filter(pattern)
