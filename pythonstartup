#-----------------------------------------------------------------------------------------------------------------------
#
# Python Startup File
#
# Author:           Brandon Perez <bmperez@alumni.cmu.edu>
# Creation Date:    Tuesday, February 16, 2016 at 11:19:26 AM EDT
#
# This file is executed whenever an interactive Python session starts up, and it sets up persistent command history, tab
# completion, and default imported modules for the session.
#
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
# Readline Settings
#-----------------------------------------------------------------------------------------------------------------------

def _setup_readline():
    """Sets up tab completion and persistent command history for the interactive session."""

    # The readline library is only supported on Linux and Mac system.
    import platform
    if platform.system().lower() != 'linux':
        return

    # General Imports
    import atexit
    from os import path

    # Readline Imports
    import readline
    import rlcompleter

    # Enable tab completion to be used in the Python interpreter.
    readline.parse_and_bind('tab: complete')

    # Set the persistent command history to be unlimited in size.
    readline.set_history_length(-1)

    # Read the contents of the Inputrc initialization file to get the standard readline settings.
    inputrc_path = path.join(path.expanduser('~'), '.inputrc')
    readline.read_init_file(inputrc_path)

    # Read the contents of the Python history file if one currently exists to get the command history.
    history_path = path.join(path.expanduser('~'), '.python_history')
    if path.exists(history_path):
        readline.read_history_file(history_path)

    # When the interpreter exits, write the new history to the history file to enable persistent command history. Note
    # that this also includes the history that was read from the file, so this is effectively an append operation.
    atexit.register(readline.write_history_file, history_path)

# Remove setup Readline function so it doesn't pollute the interactive session's namespace.
_setup_readline()
del _setup_readline

#-----------------------------------------------------------------------------------------------------------------------
# Prompt Settings
#-----------------------------------------------------------------------------------------------------------------------

def _get_color(color):
    """Gets the string code to represent the given color or modifier in the terminal by its name name (e.g green,
    magenta_background, normal, bold, etc). The returned string also has the appropriate delimiters so the color can be
    used in a Python prompt string."""

    # If Python is not being run on a Linux system, then the curses library is unavailable, so colors cannot be used.
    import platform
    if platform.system().lower() != 'linux':
        return ''

    # Otherwise, if the current terminal does not support color codes, then they cannot be used.
    import curses
    curses.setupterm()
    if curses.tigetstr('setaf') is None:
        return ''

    # Get ANSI color and modification codes for terminal text for the various colors and modifiers.
    get_color = lambda color: curses.tparm(curses.tigetstr('setaf'), color).decode('utf-8')
    get_background = lambda color: curses.tparm(curses.tigetstr('setab'), color).decode('utf-8')
    color_dict = {
            'green':                get_color(curses.COLOR_GREEN),
            'magenta_background':   get_background(curses.COLOR_MAGENTA),
            'normal':               curses.tigetstr('sgr0').decode('utf-8'),
            'yellow':               get_color(curses.COLOR_YELLOW),
    }

    # Return the string code for the given color. Note that the \001 and \002 delimiters tell Readline not
    # to count the characters towards the line length. This is necessary to wrap long lines properly.
    if color in color_dict:
        return '\001{}\002'.format(color_dict[color])
    else:
        raise KeyError('"{}" is not a valid color or modifier.'.format(color))

def _setup_prompt():
    """Modifies the PS1 and PS2 prompts used for the interactive session."""

    # General Imports
    import sys

    # Create a dictionary for colors to use in the format strings
    colors = ('green', 'magenta_background', 'normal', 'yellow')
    color_dict = {color_name: _get_color(color_name) for color_name in colors}

    # Override the default prompt used in the interactive session, printed at the beginning of each line, and set it up
    # to display the version of Python being used.
    sys.ps1 = '{green}[{yellow}Python-{version.major}.{version.minor}.{version.micro}{green}]>>> {normal}'.format(
            version=sys.version_info, **color_dict)

    # Override the default prompt used for line continuations, so that multi-line commands can be copied properly. Align
    # the lines with the PS1 prompt length, so function definitions look nice.
    ps1_len = len('[Python-{version.major}.{version.minor}.{version.micro}]>>> '.format(version=sys.version_info))
    sys.ps2 = '{magenta_background}{space:<{ps2_len}}{normal} '.format(ps2_len=ps1_len - 1, space=' ', **color_dict)

# Remove the setup prompt function so it doesn't pollute the interactive session's namespace.
_setup_prompt()
del _get_color, _setup_prompt

#-----------------------------------------------------------------------------------------------------------------------
# Default Modules
#-----------------------------------------------------------------------------------------------------------------------

# Provides an improved version of the `dir` function, for listing the members of an object.
from see import see

# Import the various container types and iteration tools so they can be used from the interpreter.
from collections import *
from itertools import *

#-----------------------------------------------------------------------------------------------------------------------
# Defined Functions
#-----------------------------------------------------------------------------------------------------------------------

def see_filter(obj, pattern):
    """Filters the members of the given object using a wildcard pattern or regex.

    This is a shorthand alias for see(obj).filter(pattern). Note that all members of a object begin with a '.'
    character, so this needs to be in the pattern. Regular expressions can be specified if the string begins with a
    forward-slash '/'.
    """

    return see(obj).filter(pattern)

def wildcard_import_file(python_file_path):
    """Emulates a wildcard import of the Python file at the given path, if it exists.

    This follows the behavior of a wildcard import (i.e. `from module import *`). If the module defines `__all__`, then
    only those names are imported. Otherwise, all names are imported which do not start with an underscore.
    """

    # General Imports
    import importlib
    from os import path

    # If there is no local Python startup file, then we do nothing.
    if not path.exists(python_file_path):
        return

    # Otherwise, dynamically import the module with import lib's facilities.
    python_file_name = path.splitext(path.basename(python_file_path))[0]
    module_loader = importlib.machinery.SourceFileLoader(python_file_name, python_file_path)
    module_spec = importlib.util.spec_from_loader(module_loader.name, module_loader)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)

    # Emulate a wildcard import by importing all user-defined or specified variables into the global namespace. This is
    # either the `__all__` attribute, or all names that don't start with an underscore if `__all__` is not defined.
    default_import_variables = [name for name in module.__dict__.keys() if not name.startswith('_')]
    module_user_defined = getattr(module, '__all__', default_import_variables)
    module_variables = {name: getattr(module, name) for name in module_user_defined}
    globals().update(module_variables)

#-----------------------------------------------------------------------------------------------------------------------
# Machine-Local Settings
#-----------------------------------------------------------------------------------------------------------------------

def _import_local_startup():
    """Imports the local Python startup file, if one exists."""

    # General Imports
    from os import path

    local_pythonstartup_path = path.join(path.expanduser('~'), '.pythonstartup_local')
    wildcard_import_file(local_pythonstartup_path)

# Import the local Python startup file if one exists.
_import_local_startup()
del _import_local_startup
